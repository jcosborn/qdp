<html lang="en">
<head>
<title>Datatypes - QDP/C User Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="QDP/C User Manual">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Compilation-with-QDP.html#Compilation-with-QDP" title="Compilation with QDP">
<link rel="next" href="QDP-Functions.html#QDP-Functions" title="QDP Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Datatypes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="QDP-Functions.html#QDP-Functions">QDP Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Compilation-with-QDP.html#Compilation-with-QDP">Compilation with QDP</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">3 Datatypes</h2>

<!-- ==================================================================== -->
<p>The N_d dimensional lattice consists of all the space-time sites in
the problem space.  Lattice data are fields on these sites.  A data
primitive describes data on a single site.  The lattice fields consist
of the primitives over all sites.  We do not define data types
restricted to a subset of the lattice &ndash; rather, lattice fields occupy
the entire lattice.

<h3 class="section">3.1 Generic Names</h3>

<p>The linear algebra portion of the QDP API is designed to resemble the
Level 1 QLA API.  Thus the datatypes and function naming conventions
are similar.  As with QLA there are two levels of generic naming:
fully generic in which both color and precision may be controlled
globally through two macros and color-generic in which precision is
explicit but not color.  Generic naming applies to datatypes, module
names, and accessor macros and follows similar rules.

   <p>Names for fully generic datatypes are listed in the table below.

   <p><table summary="">
<tr align="left"><td valign="top" width="30%">Name </td><td valign="top" width="20%">Abbreviation </td><td valign="top" width="50%">Description

<p><br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_RandomState</code> </td><td valign="top" width="20%"><code>S</code>          </td><td valign="top" width="50%">implementation dependent
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_Int</code> </td><td valign="top" width="20%"><code>I</code>          </td><td valign="top" width="50%">integer
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_Real</code> </td><td valign="top" width="20%"><code>R</code>          </td><td valign="top" width="50%">real
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_Complex</code> </td><td valign="top" width="20%"><code>C</code>          </td><td valign="top" width="50%">complex
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_ColorVector</code> </td><td valign="top" width="20%"><code>V</code>          </td><td valign="top" width="50%">one-spin, N_c color spinor
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_HalfFermion</code> </td><td valign="top" width="20%"><code>H</code>          </td><td valign="top" width="50%">two-spin, N_c color spinor
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_DiracFermion</code> </td><td valign="top" width="20%"><code>D</code>          </td><td valign="top" width="50%">four-spin, N_c color spinor
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_ColorMatrix</code> </td><td valign="top" width="20%"><code>M</code>          </td><td valign="top" width="50%">N_c \times N_c complex matrix
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>QDP_DiracPropagator</code> </td><td valign="top" width="20%"><code>P</code>          </td><td valign="top" width="50%">4 N_c \times 4 N_c complex matrix

   <br></td></tr></table>

<p class="noindent">The name for the corresponding primitive type, also known as the QLA
type, is obtained by replacing the <code>QDP</code> prefix with a <code>QLA</code>
prefix.  Thus <code>QLA_ColorMatrix</code> is the primitive (QLA) type associated
with the field <code>QDP_ColorMatrix</code>.

   <p>Names for color-generic datatypes are obtained by inserting
<code>_F</code> for single precision or <code>_D</code> for double precision
after <code>QDP</code> where appropriate. 
Thus <code>QDP_D_ColorMatrix</code> specifies a double precision color
matrix with color to be set through a global macro.

   <p>A long double precision type with abbreviation <code>Q</code> is defined for
QLA, but currently not for QDP.

<h3 class="section">3.2 Specific Types for Color and Precision</h3>

<p>According to the chosen color and precision, names for specific
floating point types are constructed from names for generic types. 
Thus QDP_ColorMatrix becomes <code>QDP_PC_ColorMatrix</code>, where the precision
<code>P</code> is <code>F</code> or <code>D</code> according to the table below

   <p><table summary="">
<tr align="left"><td valign="top" width="30%">Abbreviation </td><td valign="top" width="70%">Description

<p><br></td></tr><tr align="left"><td valign="top" width="30%"><code>F</code>     </td><td valign="top" width="70%">single precision
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>D</code>     </td><td valign="top" width="70%">double precision

   <br></td></tr></table>

<p class="noindent">and <code>C</code> is <code>2</code>, <code>3</code>, or <code>N</code>, if color is a
consideration, as listed below.

   <p><table summary="">
<tr align="left"><td valign="top" width="30%">Abbreviation </td><td valign="top" width="70%">Description

<p><br></td></tr><tr align="left"><td valign="top" width="30%"><code>2</code>     </td><td valign="top" width="70%">SU(2)
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>3</code>     </td><td valign="top" width="70%">SU(3)
<br></td></tr><tr align="left"><td valign="top" width="30%"><code>N</code>     </td><td valign="top" width="70%">SU(N)

   <br></td></tr></table>

<p class="noindent">If the datatype carries no color, the color label is omitted. 
Integers also have no precision label.  Likewise for functions, if
none of the arguments carry color, the color label is omitted, and if
all numeric arguments are integers, the precision label is omitted. 
For example, the type <code>QDP_F3_DiracFermion</code>
describes a single-precision four-spin, three-color spinor field. 
The general color choice <code>N</code> can also be used for specialized
SU(2) or SU(3) at the cost of degrading performance.

<h3 class="section">3.3 Color and Precision Uniformity</h3>

<p>In standard coding practice it is assumed that a user keeps one of the
precision and color options in force throughout the compilation.  So
as a rule all functions in the interface take operands of the same
precision and color.  As with data type names, function names come in
generic and color- and precision-specific forms, as described in the
next section.  Exceptions to this rule are functions that explicitly
convert from double to single precision and vice versa.  These and
functions that do not depend on color or precision are divided among
thirteen separate libraries.  If the user chooses to adopt color and
precision uniformity, then all variables can be defined with generic
types and all functions accessed through generic names.  The
prevailing color and precision is then defined through macros.  The
interface automatically translates data type names and function names
to the appropriate specific type names through typedefs and macros. 
With such a scheme and careful coding, changing only two macros and
the QDP library converts code from one color and precision choice to
another.

<h3 class="section">3.4 Breaking Color and Precision Uniformity</h3>

<p>It is permissible for a user to mix precision and color choices.  This
is done by declaring variables with specific type names, using
functions with specific names, and making appropriate precision
conversions when needed.  In this case it may be necessary to link
against a larger set of libraries.

<!-- ==================================================================== -->
</body></html>

